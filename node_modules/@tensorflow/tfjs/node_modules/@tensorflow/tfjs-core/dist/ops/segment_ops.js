"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var tensor_util_1 = require("../tensor_util");
var util_1 = require("../util");
var array_ops_1 = require("./array_ops");
var axis_util_1 = require("./axis_util");
var binary_ops_1 = require("./binary_ops");
var compare_1 = require("./compare");
var logical_ops_1 = require("./logical_ops");
var operation_1 = require("./operation");
var tensor_ops_1 = require("./tensor_ops");
var SegmentOps = (function () {
    function SegmentOps() {
    }
    SegmentOps.unsortedSegmentSum = function (x, segmentIds, numSegments) {
        var $x = tensor_util_1.convertToTensor(x, 'x', 'unsortedSegmentSum');
        var $segmentIds = tensor_util_1.convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');
        util_1.assert($segmentIds.dtype === 'int32', 'segmentIds must be of dtype `int32`');
        util_1.assert(util_1.isInt(numSegments), 'numSegments must be of dtype int');
        var gradFunc = function (dy) {
            var derX = function () {
                return gatherDropNegatives(dy, $segmentIds);
            };
            return { $x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) {
            return backend.unsortedSegmentSum($x, $segmentIds, numSegments);
        }, { $x: $x }, gradFunc);
    };
    SegmentOps.gather = function (x, indices, axis) {
        if (axis === void 0) { axis = 0; }
        var $x = tensor_util_1.convertToTensor(x, 'x', 'gather');
        var $indices = tensor_util_1.convertToTensor(indices, 'indices', 'gather', 'int32');
        util_1.assert($indices.dtype === 'int32', 'Indices must be of dtype `int32`');
        axis = axis_util_1.parseAxisParam(axis, $x.shape)[0];
        var grad = function (dy) {
            var derX = function () {
                if (axis === 0) {
                    return SegmentOps.unsortedSegmentSum(dy, $indices, $x.shape[axis]);
                }
                var paramsShape = $x.shape;
                var indicesSize = $indices.size;
                var outerShape = paramsShape.slice(0, axis);
                var outerDims = outerShape.length;
                var innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);
                var innerDims = innerShape.length;
                var outerAxesIndices = arrayRange(0, outerDims);
                var innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);
                var valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);
                var values = dy.reshape(valuesShape);
                var reshapedIndices = $indices.reshape([indicesSize]);
                var transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);
                var valuesTranspose = values.transpose(transposeDims);
                var paramsGrad = SegmentOps.unsortedSegmentSum(valuesTranspose, reshapedIndices, $x.shape[axis]);
                var invertTransposeDims = axis_util_1.getUndoAxesPermutation(transposeDims);
                paramsGrad = paramsGrad.transpose(invertTransposeDims);
                return paramsGrad;
            };
            return { $x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.gather($x, $indices, axis); }, { $x: $x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Segment' }),
        operation_1.operation
    ], SegmentOps, "unsortedSegmentSum", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], SegmentOps, "gather", null);
    return SegmentOps;
}());
exports.SegmentOps = SegmentOps;
function arrayRange(start, stop) {
    var result = [];
    for (var i = start; i < stop; ++i) {
        result.push(i);
    }
    return result;
}
function arrayConcat(arrays) {
    var result = [];
    for (var i = 0; i < arrays.length; ++i) {
        for (var j = 0; j < arrays[i].length; ++j) {
            result.push(arrays[i][j]);
        }
    }
    return result;
}
function gatherDropNegatives(x, indices) {
    var zeroClippedIndices = binary_ops_1.BinaryOps.maximum(indices, tensor_ops_1.TensorOps.zerosLike(indices));
    var gathered = SegmentOps.gather(x, zeroClippedIndices);
    var isPositive = compare_1.CompareOps.greaterEqual(indices, tensor_ops_1.TensorOps.scalar(0, 'int32'));
    var numIters = gathered.rank - isPositive.rank;
    for (var i = 0; i < numIters; ++i) {
        isPositive = array_ops_1.ArrayOps.expandDims(isPositive, i + 1);
    }
    isPositive =
        logical_ops_1.LogicalOps.logicalAnd(isPositive, tensor_ops_1.TensorOps.ones(gathered.shape, 'bool'));
    var zeroSlice = tensor_ops_1.TensorOps.zerosLike(gathered);
    return logical_ops_1.LogicalOps.where(isPositive, gathered, zeroSlice);
}
//# sourceMappingURL=segment_ops.js.map